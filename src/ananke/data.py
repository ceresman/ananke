# Copyright 2023 undefined
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Any
from ananke.base import BaseChunk
from dataclasses import dataclass

        





# ---------------------------------------------------------------------------- #
#                                 Core DataType                                #
# ---------------------------------------------------------------------------- #



@dataclass
class structed_chunk:
    metadata: dict = None
    graph: Any = None
    vector: Any = None
    relation_db_index: Any = None
    chunk_id: Any = None
    chunk_type: Any = None
    chunk_content: Any = None
    chunk_content_type: Any = None
    chunk_content_encoding: Any = None
    chunk_content_language: Any = None
    chunk_content_length: Any = None
    chunk_content_encoding: Any = None




        
class StructuredChunks(BaseChunk):
    def __init__(self):
        """
        > chunks are the basic unit of data storage in Ananke.
        Include all kinds of data, such as text, image, video, audio, etc.
        In normal cases, chunks are stored in a structured way.
        The core goal is use chunk group graph/vector/relational database can be indexed and searched.
        ****
        * metadata: structured data that describes the chunk, such as title, author, etc. 
        normally parse from document and media subject.
        * graph: structured data that describes the relationship & nodes this chunk. 
        need to be formatted by neo4j ot nebula style.
        * vector: embedding of the chunk, normally generated by deep learning model.
        * relation_db_index: index of the chunk in relation database, normally generated by uuid.
        * chunk_id: unique id of the chunk, normally generated by uuid.
        * chunk_type: type of the chunk, normally define by loader.
        * chunk_content: content of the chunk.
        """
        super().__init__()
        self.type = "StructuredChunks"
        
        self.batch = []
    
    
    
    
    # ---------------------------------------------------------------------------- #
    #                                   Operation                                  #
    # ---------------------------------------------------------------------------- #
    
    
        
    def __str__(self):
        return f"StructuredChunks({self.chunk_id})"
    
    def __repr__(self):
        return f"StructuredChunks({self.chunk_id})"
    
    def __eq__(self, other):
        return self.chunk_id == other.chunk_id
    
    def __hash__(self):
        return hash(self.chunk_id)
    
    def __lt__(self, other):
        return self.chunk_id < other.chunk_id
    
    def __gt__(self, other):
        return self.chunk_id > other.chunk_id
    
    def __le__(self, other):
        return self.chunk_id <= other.chunk_id
    def __ge__(self, other):
        return self.chunk_id >= other.chunk_id
    def __ne__(self, other):
        return self.chunk_id != other.chunk_id
    def __contains__(self, item):
        return item in self.chunk_content
    def __len__(self):
        return len(self.chunk_content)
    
    def __getitem__(self, item):
        return self.chunk_content[item]
    def __setitem__(self, key, value):
        self.chunk_content[key] = value
        
    def __delitem__(self, key):
        del self.chunk_content[key]
    def __iter__(self):
        return iter(self.chunk_content)    
    
    def __name__(self):
        return self.type